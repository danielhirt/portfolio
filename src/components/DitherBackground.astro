---
---

<canvas id="dither-bg"></canvas>

<style>
  #dither-bg {
    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    z-index: 0;
    opacity: 0.15;
    pointer-events: none;
  }
</style>

<script>
  import vertSrc from '../shaders/dither.vert.glsl?raw';
  import fragSrc from '../shaders/dither.frag.glsl?raw';

  function initDitherBackground() {
    const canvas = document.getElementById('dither-bg') as HTMLCanvasElement;
    if (!canvas) return;

    const gl = canvas.getContext('webgl2', { alpha: false, antialias: false });
    if (!gl) {
      console.warn('WebGL2 not supported, dither background disabled');
      return;
    }

    // --- Compile shader ---
    function createShader(type: number, source: string): WebGLShader | null {
      const shader = gl!.createShader(type);
      if (!shader) return null;
      gl!.shaderSource(shader, source);
      gl!.compileShader(shader);
      if (!gl!.getShaderParameter(shader, gl!.COMPILE_STATUS)) {
        console.error('Shader compile error:', gl!.getShaderInfoLog(shader));
        gl!.deleteShader(shader);
        return null;
      }
      return shader;
    }

    const vert = createShader(gl.VERTEX_SHADER, vertSrc);
    const frag = createShader(gl.FRAGMENT_SHADER, fragSrc);
    if (!vert || !frag) return;

    const program = gl.createProgram()!;
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      console.error('Program link error:', gl.getProgramInfoLog(program));
      return;
    }
    gl.useProgram(program);

    // Need a VAO for WebGL2 even with no attributes
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);

    // --- Uniform locations ---
    const loc = {
      uResolution: gl.getUniformLocation(program, 'uResolution'),
      uTime: gl.getUniformLocation(program, 'uTime'),
      uMouse: gl.getUniformLocation(program, 'uMouse'),
      uClickPos: gl.getUniformLocation(program, 'uClickPos'),
      uClickTimes: gl.getUniformLocation(program, 'uClickTimes'),
      uInkColor: gl.getUniformLocation(program, 'uInkColor'),
      uBgColor: gl.getUniformLocation(program, 'uBgColor'),
      uPixelSize: gl.getUniformLocation(program, 'uPixelSize'),
    };

    // --- State ---
    let mouseX = 0;
    let mouseY = 0;
    const clickPos = new Float32Array(20); // 10 * vec2
    const clickTimes = new Float32Array(10);
    let clickIndex = 0;
    const startTime = performance.now() / 1000;

    const PIXEL_SIZE = 5.0;

    // --- Theme colors ---
    const COLORS = {
      dark: { ink: [0.898, 0.914, 0.941], bg: [0.059, 0.071, 0.098] },   // #e5e9f0 on #0f1219
      light: { ink: [0.133, 0.161, 0.224], bg: [1.0, 1.0, 1.0] },         // #222939 on #ffffff
    };

    function isDarkMode(): boolean {
      return document.documentElement.classList.contains('dark');
    }

    function getThemeColors() {
      return isDarkMode() ? COLORS.dark : COLORS.light;
    }

    // --- Resize ---
    function resize() {
      const dpr = Math.min(window.devicePixelRatio, 2);
      const w = window.innerWidth;
      const h = window.innerHeight;
      canvas.width = w * dpr;
      canvas.height = h * dpr;
      // CSS size is handled by the fixed positioning styles
      gl!.viewport(0, 0, canvas.width, canvas.height);
    }
    resize();
    window.addEventListener('resize', resize);

    // --- Mouse tracking (on window, not canvas) ---
    window.addEventListener('mousemove', (e) => {
      const dpr = Math.min(window.devicePixelRatio, 2);
      mouseX = e.clientX * dpr;
      mouseY = (window.innerHeight - e.clientY) * dpr; // flip Y for GL
    });

    // --- Click ripples ---
    window.addEventListener('click', (e) => {
      const dpr = Math.min(window.devicePixelRatio, 2);
      const i = clickIndex % 10;
      clickPos[i * 2] = e.clientX * dpr;
      clickPos[i * 2 + 1] = (window.innerHeight - e.clientY) * dpr;
      clickTimes[i] = performance.now() / 1000 - startTime;
      clickIndex++;
    });

    // --- Theme observer ---
    const observer = new MutationObserver(() => {
      // Colors update on next frame automatically via getThemeColors()
    });
    observer.observe(document.documentElement, {
      attributes: true,
      attributeFilter: ['class'],
    });

    // --- Render loop ---
    let animId: number;

    function render() {
      const now = performance.now() / 1000 - startTime;
      const colors = getThemeColors();

      gl!.uniform2f(loc.uResolution, canvas.width, canvas.height);
      gl!.uniform1f(loc.uTime, now);
      gl!.uniform2f(loc.uMouse, mouseX, mouseY);
      gl!.uniform2fv(loc.uClickPos, clickPos);
      gl!.uniform1fv(loc.uClickTimes, clickTimes);
      gl!.uniform3f(loc.uInkColor, colors.ink[0], colors.ink[1], colors.ink[2]);
      gl!.uniform3f(loc.uBgColor, colors.bg[0], colors.bg[1], colors.bg[2]);
      gl!.uniform1f(loc.uPixelSize, PIXEL_SIZE * Math.min(window.devicePixelRatio, 2));

      gl!.drawArrays(gl!.TRIANGLES, 0, 3);
      animId = requestAnimationFrame(render);
    }

    // Pause when tab is hidden
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cancelAnimationFrame(animId);
      } else {
        animId = requestAnimationFrame(render);
      }
    });

    animId = requestAnimationFrame(render);
  }

  // Initialize on page load and on Astro page transitions
  initDitherBackground();
  document.addEventListener('astro:after-swap', initDitherBackground);
</script>
